<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Resilient Habit Guard</title>
  <style>
    body, html { margin:0; padding:0; background:#000; height: 100vh; overflow: hidden; }
    #container {
      position: relative;
      width: 100vw;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    #webcam, #overlay {
      position: absolute;
      transform: scaleX(-1); 
      max-width: 100%;
      max-height: 100%;
    }
    #status {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-family: sans-serif;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px 20px;
      border-radius: 20px;
      z-index: 10;
      pointer-events: none;
      text-align: center;
      transition: opacity 0.5s;
    }
  </style>
</head>
<body>
  <div id="status">Starting System...</div>
  <div id="container">
    <video id="webcam" autoplay muted playsinline></video>
    <canvas id="overlay"></canvas>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>

  <script type="module">
    import { HandLandmarker, FaceLandmarker, FilesetResolver }
      from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

    // --- CONFIGURATION ---
    const BEEP_COOLDOWN = 800;    
    const BOX_WIDTH_SCALE = 0.75; // Increased width (was 0.6)
    const BOX_PADDING_Y = 0.08;   // Increased height padding

    // VARIABLES
    let handLandmarker, faceLandmarker;
    let audioCtx;
    let lastBeep = 0;
    let faceZone = null;
    let videoElement = null;
    let canvasElement = null;
    let ctx = null;
    let isRestarting = false;
    let lastVideoTime = 0;
    let stuckFrameCount = 0;

    // --- WORKER FOR BACKGROUND PROCESSING ---
    const workerBlob = new Blob([`
      self.onmessage = function(e) {
        if (e.data === "start") {
          setInterval(() => { postMessage("tick"); }, 100);
        }
      };
    `], { type: "text/javascript" });
    const worker = new Worker(URL.createObjectURL(workerBlob));

    async function init() {
      const status = document.getElementById("status");
      videoElement = document.getElementById("webcam");
      canvasElement = document.getElementById("overlay");
      ctx = canvasElement.getContext("2d");

      // 1. Audio
      try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e){}

      // 2. Load Models
      status.innerText = "Loading AI Models...";
      const vision = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
      );
      
      handLandmarker = await HandLandmarker.createFromOptions(vision, {
        baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task", delegate: "GPU" },
        runningMode: "VIDEO", numHands: 1
      });

      faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
        baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task", delegate: "GPU" },
        runningMode: "VIDEO", numFaces: 1
      });

      // 3. Start Camera
      await startCamera();
      
      // 4. Start Worker
      worker.postMessage("start");
      
      // 5. Add Wake-up Listener (Backup)
      document.addEventListener("visibilitychange", () => {
        if (document.visibilityState === "visible") {
          checkCameraHealth();
        }
      });
    }

    async function startCamera() {
      const status = document.getElementById("status");
      try {
        status.innerText = "Activating Camera...";
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        videoElement.srcObject = stream;
        
        // Wait for video to actually play
        await new Promise((resolve) => {
          videoElement.onloadeddata = () => {
            canvasElement.width = videoElement.videoWidth;
            canvasElement.height = videoElement.videoHeight;
            videoElement.play();
            resolve();
          };
        });
        
        status.innerText = "Active. Monitoring...";
        setTimeout(() => { status.style.opacity = "0.5"; }, 2000);
        isRestarting = false;
        
      } catch (err) {
        console.error("Camera Error:", err);
        status.innerText = "Camera Error! Click here to retry.";
        status.onclick = () => location.reload();
      }
    }

    // --- RESTART LOGIC (For Sleep/Wake) ---
    async function checkCameraHealth() {
      if (isRestarting) return;

      // Logic: If video currentTime hasn't changed in 20 ticks (2 seconds), it's frozen.
      if (videoElement.currentTime === lastVideoTime) {
        stuckFrameCount++;
      } else {
        stuckFrameCount = 0;
        lastVideoTime = videoElement.currentTime;
      }

      // If stuck for > 2 seconds (20 ticks), force restart
      if (stuckFrameCount > 20) {
        console.log("Camera appears frozen. Restarting...");
        isRestarting = true;
        
        // Stop old tracks
        if (videoElement.srcObject) {
          videoElement.srcObject.getTracks().forEach(track => track.stop());
        }
        
        document.getElementById("status").innerText = "Waking up camera...";
        document.getElementById("status").style.opacity = "1";
        
        // Small delay to let OS release camera
        setTimeout(startCamera, 1000); 
        stuckFrameCount = 0;
      }
    }

    // --- MAIN LOOP ---
    worker.onmessage = function(e) {
      if (e.data === "tick") {
        runDetection();
      }
    };

    function runDetection() {
      // 0. Watchdog Check
      if (videoElement && videoElement.readyState >= 2) {
        checkCameraHealth();
      } else {
        return; // Camera not ready
      }

      if (!handLandmarker || !faceLandmarker) return;

      const now = performance.now();
      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

      // 1. Detect Face
      const faceResult = faceLandmarker.detectForVideo(videoElement, now);
      if (faceResult.faceLandmarks && faceResult.faceLandmarks.length > 0) {
        updateFaceZone(faceResult.faceLandmarks[0]);
        drawFaceZone(ctx);
      } else {
        faceZone = null;
      }

      // 2. Detect Hands
      if (faceZone) {
        const handResult = handLandmarker.detectForVideo(videoElement, now);
        if (handResult.landmarks && handResult.landmarks.length > 0) {
          const hand = handResult.landmarks[0];
          
          // Draw Hand (Subtle Green)
          drawConnectors(ctx, hand, HAND_CONNECTIONS, { color: "rgba(0, 255, 0, 0.2)", lineWidth: 2 });

          if (checkCollision(hand)) {
             // Red Alert
             drawConnectors(ctx, hand, HAND_CONNECTIONS, { color: "rgba(255, 0, 0, 0.8)", lineWidth: 4 });
             if (now - lastBeep > BEEP_COOLDOWN) {
               playNotificationSound();
               lastBeep = now;
             }
          }
        }
      }
    }

    // --- DIMENSIONS LOGIC ---
    function updateFaceZone(landmarks) {
      // Points: 1(Nose), 152(Chin), 234(Left Edge), 454(Right Edge)
      const nose = landmarks[1];
      const chin = landmarks[152];
      const leftEdge = landmarks[234].x;
      const rightEdge = landmarks[454].x;

      const centerX = (leftEdge + rightEdge) / 2;
      const fullWidth = Math.abs(rightEdge - leftEdge);
      const scaledWidth = fullWidth * BOX_WIDTH_SCALE; 

      faceZone = {
        minX: centerX - (scaledWidth / 2),
        maxX: centerX + (scaledWidth / 2),
        minY: nose.y - BOX_PADDING_Y, // Higher
        maxY: chin.y + BOX_PADDING_Y  // Lower
      };
    }

    function drawFaceZone(ctx) {
      if (!faceZone) return;
      const w = ctx.canvas.width;
      const h = ctx.canvas.height;
      
      const bx = faceZone.minX * w;
      const by = faceZone.minY * h;
      const bw = (faceZone.maxX - faceZone.minX) * w;
      const bh = (faceZone.maxY - faceZone.minY) * h;

      ctx.strokeStyle = "rgba(0, 200, 255, 0.4)";
      ctx.lineWidth = 2;
      ctx.strokeRect(bx, by, bw, bh);
    }

    function checkCollision(hand) {
      if (!faceZone) return false;
      const tips = [8, 4, 12]; // Index, Thumb, Middle
      for (let i of tips) {
        const x = hand[i].x;
        const y = hand[i].y;
        if (x > faceZone.minX && x < faceZone.maxX && y > faceZone.minY && y < faceZone.maxY) {
          return true;
        }
      }
      return false;
    }

    function playNotificationSound() {
      if (!audioCtx) return;
      if (audioCtx.state === 'suspended') audioCtx.resume();

      const t = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      osc.type = "triangle"; 
      osc.frequency.setValueAtTime(700, t);
      osc.frequency.setValueAtTime(0, t + 0.1); 

      gain.gain.setValueAtTime(0.1, t);
      gain.gain.linearRampToValueAtTime(0.1, t + 0.05);
      gain.gain.setValueAtTime(0, t + 0.1);

      osc.connect(gain).connect(audioCtx.destination);
      osc.start();
      osc.stop(t + 0.2);
    }

    init();
  </script>
</body>
</html>
